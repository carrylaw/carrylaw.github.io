<!DOCTYPE html>
<html lang="en-us">

	<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Bmarchine &middot; 数分学长
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/minddust.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
	
	<!--typeahead-->
  <link rel="stylesheet" href="/public/css/jquery.typeahead.css">
  <link rel="stylesheet" href="/public/css/style.css">
  <script src="https://cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
  <script src="https://cdn.bootcss.com/waypoints/4.0.1/jquery.waypoints.min.js"></script>
  <script src="/public/js/jquery.typeahead.js"></script>
  <script src="/public/js/tools.js"></script>

</head>


	<body>

		<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p><font size="5" color="darkgray" face="times new roman">Carry.law</font></p>
	<p><font size="2" color="darkgray" face="微软雅黑">一枚最不像数分师的数据分析师</font></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">主页</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">关于</a>
        
      
    
      
    
      
    
      
        
      
    
    <a class="sidebar-nav-item" id="articles" expanded='true'>博文馆</a>
   	
      
		<a class="sidebar-nav-item category-name-show" name="category-name" href="/blog/category/anlp/">- 自然语言处理</a>
    
		<a class="sidebar-nav-item category-name-show" name="category-name" href="/blog/category/bmarchine/">- 机器学习实战</a>
    
		<a class="sidebar-nav-item category-name-show" name="category-name" href="/blog/category/cpython/">- Python技术</a>
    
		<a class="sidebar-nav-item category-name-show" name="category-name" href="/blog/category/emysql/">- 数据库技术</a>
    
		<a class="sidebar-nav-item category-name-show" name="category-name" href="/blog/category/ynews/">- 相关资讯</a>
    
    <span class="sidebar-nav-item">&copy; 2017. All rights reserved.</span>
  </nav>
</div>


		<!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
		<div class="wrap">
			<div class="masthead">
				<div class="container">
					<img src="/public/logo.png" class="masthead-img masthead-inner masthead-shrink"/>						
					<h3 class="masthead-title masthead-inner masthead-shrink" >
					
						<a href="/blog/category/bmarchine/" title="Home">机器学习实战</a>
			            <small class="font-kt">分类文章</small>					    
    				
					</h3>
					<div class="masthead-nav masthead-inner">
						<nav class="nav-top">
	<ul class="text-xs-center">
		<li>
			<!--检索框-->
			<form id="search-bar" action="/search" target="_blank" onsubmit="encodeKeyword()">
	<div class="typeahead__container">
		<div class="typeahead__field">

			<span class="typeahead__query">
                <input class="js-typeahead"
                       name="q"
                       type="search"
                       autocomplete="off">
            </span>
			<span class="typeahead__button" hidden="hidden">
                <button type="submit">
                    <span class="typeahead__search-icon"></span>
				</button>
			</span>

		</div>
	</div>
</form>    
		</li>
		<li><a href="#" id="search-btn" class="label label-darkblue tooltip" title="search"><span class="icon icon-search"></span></a></li>
		<li class="site-name"><a href="/" class="label label-darkblue character">数分学长</a></li>
		<li><a href="/atom.xml" class="label label-darkblue tooltip" title="RSS" target="_blank"><span class="icon icon-rss"></span></a></li>
		<li><a href="https://github.com/carrylaw" class="label label-darkblue tooltip" title="GitHub" target="_blank"><span class="icon icon-github"></span></a></li>
	</ul>
</nav>

<!--		<li><a href="http://www.jianshu.com/u/5caa2bf26f9b" class="label label-darkblue tooltip" title="jianshu" target="_blank"><span class="icon icon-jian"></span></a></li>-->
					</div>
				</div>
			</div>

			<div class="container content">
				<div class="posts">

 
 	  <div class="post hidden">
    <h1 class="post-title">
      <a href="/bmarchine/2017/10/13/ml02/">
        Python机器学习算法之非线性回归
      </a>
    </h1>
    <span class="post-date" >13 Oct 2017</span>
    <div class="post-content">
         
            非线性回归相较于线性回归而言，总带有一丢丢复杂的神秘感。关于线性回归模型相信各位已耳熟能详，因此这里主要讨论非线性回归模型。其实非线性回归中很大一部分是基于多项式的回归模型，即利用曲线方程代替直线方程拟合坐标图上各点，使得各点到曲线的距离总和最短。   
  一元m次多项式回归方程为：
&lt;div align="center"&gt;

&lt;/div&gt;
  二元二次多项式回归方程为：
&lt;div align="center"&gt;

&lt;/div&gt;
  多项式回归的最大优点就是可以通过增加x的高次项对实测点进行逼近，直至满意为止。事实上，多项式回归可以处理很大一类非线性问题，它在分析中占有重要的地位，因为任何一个函数都可以分段用多项式来逼近。   
  举一个房屋价格与房屋尺寸非线性拟合的实例，数据集下载地址：prices.txt

· 算法构建代码
# python -version 3.5+   
import matplotlib.pyplot as plt    
import numpy as np    
from sklearn import linear_model   
from sklearn.preprocessing import PolynomialFeatures   

# 读取数据集
datasets_X = [] #建立datasets_X储存房屋尺寸数据
datasets_Y = [] #建立datasets_Y储存房屋成交价格数据
fr = open('E:\\prices.txt', 'r', encoding='utf-8') #指定prices.txt数据集所在路径
lines = fr.readlines() #读取一整个文件夹
for line in lines: #逐行读取，循环遍历所有数据
    items = line.strip().split(",") #变量之间按逗号进行分隔
    datasets_X.append(int(items[0])) #读取的数据转换为int型
    datasets_Y.append(int(items[1]))

# 数据预处理
length = len(datasets_X)
datasets_X = np.array(datasets_X).reshape([length, 1]) #将datasets_X转化为数组
datasets_Y = np.array(datasets_Y)
minX = min(datasets_X) #以数据datasets_X的最大值和最小值为范围，建立等差数列，方便后续画图
maxX = max(datasets_X)
X = np.arange(minX, maxX).reshape([-1, 1])

# 数据建模
poly_reg = PolynomialFeatures(degree=2) #degree=2表示二次多项式
X_poly = poly_reg.fit_transform(datasets_X) #构造datasets_X二次多项式特征X_poly
lin_reg_2 = linear_model.LinearRegression() #创建线性回归模型
lin_reg_2.fit(X_poly, datasets_Y) #使用线性回归模型学习X_poly和datasets_Y之间的映射关系


· 测试结果代码
# 查看回归系数
print('Coefficients:',lin_reg_2.coef_)
# 查看截距项
print('intercept:',lin_reg_2.intercept_)  

# 数据可视化
plt.scatter(datasets_X, datasets_Y, color='orange')   
plt.plot(X, lin_reg_2.predict(poly_reg.fit_transform(X)), color='blue')   
plt.xlabel('Area')   
plt.ylabel('Price')   
plt.show()   


· 部分结果展示
相关系数Coefficients: [  0.00000000e+00   4.93982848e-02   1.89186822e-05]     
截距项intercept: 151.846967505     
非线性回归公式：Y = 151.8470 + 4.9398e-02*x + 1.8919e-05*x^2

非线性拟合图：
&lt;div align="center"&gt;

&lt;/div&gt;

         
    </div>
  </div>

  
 	  <div class="post hidden">
    <h1 class="post-title">
      <a href="/bmarchine/2017/08/30/ml01/">
        Python机器学习算法之逻辑回归
      </a>
    </h1>
    <span class="post-date" >30 Aug 2017</span>
    <div class="post-content">
         
            逻辑回归（Logistic Regression）是比较常见的机器学习算法之一，与SVM支持向量机类似，属于典型的 二分类算法。但逻辑回归相较于SVM的优点在于，前者不仅能够预测某事件是否将会发生，还包含该事件发生的可能性。例如想要知道张三是否会购买产品A，SVM所预测的结果只能告诉你，张三会购买或者不会购买，但逻辑回归能告诉你，张三有70%的概率购买产品A，从而你可以根据自己的业务设置风险率阀值。   
  关于逻辑回归的数学公式百度、Google已经有很好的解答，遂不再赘述。本博文主要介绍如何利用Python实现逻辑回归算法，该算法并没有引用sklearn包，因此具有一定的复杂度，但所实现的算法具有相当高的灵活性，适用于大规模数据分析系统的开发。    
  偏好使用sklearn的朋友，请跳转：sklearn主要模块和基本使用   
  输入数据集下载地址：训练集train，测试集test，预测集predict.txt

· 算法构建代码

# python -version 3.5+
import numpy as np
from numpy import *

## 构建sigmoid函数
def sigmoid(x):
    return .5 * (1 + np.tanh(.5 * x))

## 训练逻辑回归模型
def trainLogRegres(train_x, train_y, opts):
    # 构建训练样本
    numSamples, numFeatures = shape(train_x)
    alpha = opts['alpha']
    maxIter = opts['maxIter']
    weights = ones((numFeatures, 1))

    # 选择最优的梯度下降法
    for k in range(maxIter):
        if opts['optimizeType'] == 'gradDescent': # 梯度下降法
            output = sigmoid(train_x * weights)
            error = train_y - output
            weights = weights + alpha * train_x.transpose() * error
        elif opts['optimizeType'] == 'stocGradDescent': # 随机梯度下降法
            for i in range(numSamples):
                output = sigmoid(train_x[i, :] * weights)
                error = train_y[i, 0] - output
                weights = weights + alpha * train_x[i, :].transpose() * error
        elif opts['optimizeType'] == 'smoothStocGradDescent': # 平稳随机梯度下降法
            dataIndex = list(range(numSamples))
            for i in range(numSamples):
                alpha = 4.0 / (1.0 + k + i) + 0.01
                randIndex = int(random.uniform(0, len(dataIndex)))
                output = sigmoid(train_x[randIndex, :] * weights)
                error = train_y[randIndex, 0] - output
                weights = weights + alpha * train_x[randIndex, :].transpose() * error
                del (dataIndex[randIndex])
        else:
            raise NameError('Not support optimize method type!')
    return weights

## 检验逻辑回归模型
def testLogRegres(weights, test_x, test_y):
    numSamples, numFeatures = shape(test_x)
    matchCount = 0
    for i in range(numSamples):
        predict = sigmoid(test_x[i, :] * weights)[0, 0] &gt; 0.5 #设置阀值为0.5
        if predict == bool(test_y[i, 0]):
            matchCount += 1
    accuracy = float(matchCount) / numSamples
    return accuracy

## 预测逻辑回归模型
def preLogRegres(weights ,pre_x):
    numSamples, numFeatures = shape(pre_x)
    outfile = open('D://predict_result.txt', 'w') # 将概率值输出到文件
    for i in range(numSamples):
        predict = sigmoid(pre_x[i, :] * weights)[0, 0]
        predict_m = sigmoid(pre_x[i, :] * weights)[0, 0] &gt; 0.5 #是否阀值定为0.5
        outfile.write(str(predict)+'\n')
        print(str(predict_m) + '  ' + str(predict)) #同时输出是否及概率值
    outfile.close()


· 测试结果代码

## step 1: 模型训练
def loadData(): # 载入训练集
    train_x = []
    train_y = []
    fileIn = open('D://train.txt')
    for line in fileIn.readlines():
        lineArr = line.split() #设置分隔符
        train_x.append([1.0, float(lineArr[0]), float(lineArr[1])])
        train_y.append(float(lineArr[-1]))
    return mat(train_x), mat(train_y).transpose()
    fileIn.close()
train_x, train_y = loadData()
opts = {'alpha': 0.01, 'maxIter': 20, 'optimizeType': 'smoothStocGradDescent'}  # 参数设置
optimalWeights = trainLogRegres(train_x, train_y, opts)

## step 2: 模型检验
def loadData1():
    test_x = []
    test_y = []
    fileIn = open('D://test.txt')
    for line in fileIn.readlines():
        lineArr = line.split()
        test_x.append([1.0, float(lineArr[0]), float(lineArr[1])])
        test_y.append(float(lineArr[-1]))
    return mat(test_x), mat(test_y).transpose()
    fileIn.close()
test_x, test_y = loadData1()
accuracy = testLogRegres(optimalWeights, test_x, test_y)
print('模型预测精度：' + str(accuracy))
print('================================')

## step 3: 模型预测
def loadData2():
    pre_x = []
    fileIn = open('D://predict.txt')
    for line in fileIn.readlines():
        lineArr = line.split()
        pre_x.append([1.0, float(lineArr[0]), float(lineArr[1])])
    return mat(pre_x)
    fileIn.close()
pre_x = loadData2()
print('模型预测结果：')
predict = preLogRegres(optimalWeights, pre_x)



         
    </div>
  </div>

  
  <script src="/public/js/pagination.js"></script>

</div>

			</div>
		</div>

		<label for="sidebar-checkbox" class="sidebar-toggle"></label>

		<script>
			(function(document) {
				var toggle = document.querySelector('.sidebar-toggle');
				var sidebar = document.querySelector('#sidebar');
				var checkbox = document.querySelector('#sidebar-checkbox');

				document.addEventListener('click', function(e) {
					var target = e.target;
					if(!checkbox.checked ||
						sidebar.contains(target) ||
						(target === checkbox || target === toggle)) return;

					checkbox.checked = false;
				}, false);
				
				var article = document.getElementById('articles');
				var isExpanded = article.getAttribute('expanded');
				var categoryName = document.getElementsByName('category-name');
				article.addEventListener('click', function(e) {
					if(isExpanded){
						isExpanded = false;
						for (var i=0;i<categoryName.length;i++){
							categoryName[i].setAttribute('class','sidebar-nav-item category-name-hide');
						}					
					}else{
						isExpanded = true;
						for (var i=0;i<categoryName.length;i++){
							categoryName[i].setAttribute('class','sidebar-nav-item category-name-show');
						}
					}
				}, false);
			})(document);
			$('#search-btn').on('click',function(){
				$('#search-bar').submit();
			});
		</script>
	<script src="/public/js/typeahead-custom.js"></script>
	</body>

</html>